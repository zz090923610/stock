import asyncio
import logging
import os
import socket
import threading
import traceback

import requests
from autobahn.asyncio.websocket import WebSocketClientProtocol, WebSocketClientFactory

# 用于模拟登陆新浪微博
from stock.common.time_util import TimeUtil
from stock.real_time.sina_lv2.sina_login import SinaLoginHdl


class NotLoginException(Exception):
    pass


def create_protocol(kls, symbol):
    class MyClientProtocol(WebSocketClientProtocol):
        def onConnect(self, response):
            print('server connect', TimeUtil().get_time_of_a_day())

        def onOpen(self):
            print('open')

        @asyncio.coroutine
        def onMessage(self, payload, is_binary):
            print('payload {}'.format(payload))
            # try:
            #    parse_payload(str(payload, 'utf8'))
            # except:
            #    print('parse payload error {}'.format(payload))
            #    logging.info('parse payload error')

        @asyncio.coroutine
        def onClose(self, is_clean, code, reason):
            print('closed {} {} {}'.format(is_clean, code, reason))
            yield from kls.execute(symbol)

    return MyClientProtocol


# noinspection PyBroadException
class SinaLV2Quote:
    token_url = 'https://current.sina.com.cn/auth/api/jsonp.php/varxxxl/AuthSign_Service.getSignCode'
    not_login_msg = 'pls login'
    WEB_CLIENT = 'ssologin.js(v1.4.5)'
    user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 ' \
                 '(KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36'

    lock = threading.Lock()

    @asyncio.coroutine
    def execute(self, symbol):
        try:
            base_url = 'wss://ff.sinajs.cn/wskt'
            token = yield from self.get_token(symbol)
            url = base_url + '?' + 'token=' + token + '&' + 'list=' + ','.join(symbol)
            # print('start {}'.format(url))
            factory = WebSocketClientFactory(url)
            factory.protocol = create_protocol(self, symbol)
            loop = asyncio.get_event_loop()

            co_route = loop.create_connection(factory, self.host, 80)
            asyncio.ensure_future(co_route)
        except requests.RequestException:
            print('requests error, don"t worry')
            yield from asyncio.sleep(3)
            yield from self.execute(symbol)
        except NotLoginException:
            logging.warning('not login error, try again')
            yield from asyncio.sleep(3)
            yield from self.execute(symbol)
        except:
            traceback.print_exc()
            logging.warning('unexpected error')

    def __init__(self, username, password, cookie_path):
        self.cookie_path = cookie_path
        self.username = username
        self.password = password
        self.ip = ''
        self.host = socket.gethostbyname('ff.sinajs.cn')
        self.init_public_ip()
        self.s = requests.session()
        self.s.headers['User-Agent'] = self.user_agent

    @asyncio.coroutine
    def is_login(self):
        try:
            yield from self.get_token('2cn_sh600000')
            return True
        except:
            return False

    @asyncio.coroutine
    def login(self):
        self.load_cookie()
        is_login = yield from self.is_login()
        if is_login:
            logging.info('sina quote already login')
            return
        a = SinaLoginHdl(self.username, self.password, self.cookie_path)
        a.login()
        self.load_cookie()

    def load_cookie(self):
        self.s.cookies.clear()
        try:
            if os.path.isfile(self.cookie_path):
                with open(self.cookie_path) as f:
                    for line in f.read().splitlines():
                        sp = line.split(',')
                        if len(sp) == 4:
                            self.s.cookies.set(sp[0], sp[1], domain=sp[2], path=sp[3])
        except:
            pass

    def save_cookie(self):
        try:
            with open(self.cookie_path, 'w') as f:
                for c in self.s.cookies:
                    f.write('%s,%s,%s,%s\n' % (c.name, c.value, c.domain, c.path))
        except:
            print('save cookie error')

    @asyncio.coroutine
    def get_token(self, symbols):
        if not isinstance(symbols, list):
            symbols = [symbols]
        query_type = 'A_hq'

        public_ip = self.get_public_ip()
        query_list = ','.join(symbols)
        print(query_list)

        token_url = self.token_url
        dct = {'query': query_type,
               'ip': public_ip,
               'list': query_list,
               'kick': 1
               }

        def session_get_wrapper():
            # print('dct {}'.format(dct))
            # print('token_url {}'.format(token_url))
            # print('cookie {}'.format(self.s.cookies))
            return self.s.get(token_url, params=dct).text

        loop = asyncio.get_event_loop()
        future1 = loop.run_in_executor(None, session_get_wrapper)
        res = yield from future1
        # print('res {}'.format(res))

        if self.not_login_msg in res:
            print('NOT LOGIN EXCEPTION')
            raise NotLoginException()
        else:
            token_start = res.find('\"') + 1
            token_end = res.find('\"', token_start)
            token = res[token_start: token_end]
            print('found token:  %s' % token)
            return token

    def init_public_ip(self):
        txt = requests.get('http://ipinfo.io/ip').text.strip()
        self.ip = txt
        logging.info('public ip %s' % self.ip)

    def get_public_ip(self):
        return self.ip

    @staticmethod
    def get_instance(username, password, cookie_path):
        return SinaLV2Quote(username, password, cookie_path)

    @asyncio.coroutine
    def append_stock(self, cons):
        symbol = []
        for stock in cons:
            #   symbol.append('2cn_%s' % stock)
            #   symbol.append('2cn_%s_orders' % stock)
            symbol.append('2cn_%s_0' % stock)
            symbol.append('2cn_%s_1' % stock)
            #   symbol.append('%s' % stock)
            #   symbol.append('%s_i' % stock)
            #   symbol.append('2cn_%s_1' % stock)
        yield from self.execute(symbol)


@asyncio.coroutine
def main(stock_list, username, password, cookie_path):
    # print('Stock Number {}'.format(len(stock_list)))
    instance = SinaLV2Quote.get_instance(username, password, cookie_path)
    yield from instance.login()
    asyncio.ensure_future(instance.append_stock(stock_list))


if __name__ == '__main__':
    asyncio.ensure_future(main(['sh600000'], '610153443@qq.com', 'f9c6c2827d3e5647', '/tmp/cookie'))
    asyncio.get_event_loop().run_forever()
