# -*- coding: utf-8 -*-
import os
import re
import sys

from tools.data.file_hdl import load_text, save_text


class OverviewHdl:
    def __init__(self):
        self.pwd = os.getcwd()
        self.dep_list = []
        self.apt_dep_list = []
        self.file_to_check = []
        self.todo_list = []

    def search_down_sub_path(self, root):
        files = os.listdir(root)
        for f in files:
            if os.path.isdir(root + '/' + f):
                self.search_down_sub_path(root + '/' + f)
            elif len(f.split(".")) == 2:
                if f.split(".")[1] == "py":
                    self.file_to_check.append(root + '/' + f)

    def _from_where(self, path):
        tmp = re.sub(self.pwd, '', path).lstrip("/").split(".")[0]
        return re.sub("/", ".", tmp)

    def build_cmd_cache(self):
        print("Updating command cache")
        final_py = \
            "# -*- coding: utf-8 -*-\n# This file is automatic generated by overview.py\n\n\ndef exec_ctrl_cmd(cmd):\n"
        intend = "    "
        self.search_down_sub_path(self.pwd)
        cnt = 0
        for path in self.file_to_check:
            lines = load_text(path)
            for line in lines:
                if re.search(r"#[ \t]*CMDEXPORT[ \t]*\([ \t]*[a-zA-Z0-9_ {}\[\]:]+[ \t]*\)[ \t]*[a-zA-Z0-9_]+", line):
                    # this line contains a cmd export
                    res = re.search(
                        r"#[ \t]*CMDEXPORT[ \t]*\([ \t]*([a-zA-Z0-9_ {}\[\]:]+)[ \t]*\)[ \t]*([a-zA-Z0-9_]+)", line)
                    print(line.rstrip())
                    cnt += 1
                    exported = res.group(1).strip()
                    map_to_func = res.group(2)
                    cmd_and_params = exported.split(" ")
                    cmd_min_length = len(cmd_and_params)
                    py_code_nested_if = ''
                    py_code_func_map = '%s%s(' % (intend * 3, map_to_func)
                    py_code_import_func = '%sfrom %s import %s\n' % (intend * 3, self._from_where(path), map_to_func)
                    idx = 0
                    py_code_nested_if += "%sif len(cmd) >= %d:\n" % (intend, cmd_min_length) if ":" in line \
                        else "%sif len(cmd) == %d:\n" % (intend, cmd_min_length)
                    for cp in cmd_and_params:

                        if re.search(r"{[a-zA-Z0-9_:\[\]]*}", cp):
                            # cp is a param
                            py_code_func_map += "cmd[%d]" % idx if ':' not in cp else "' '.join(cmd[%d:])" % idx
                            py_code_func_map += ", " if cp != cmd_and_params[-1] else ""
                            pass

                        else:
                            # cp is a cmd
                            py_code_nested_if += "%sif (cmd[%d] == '%s') " % (intend * 2, idx, cp) if idx == 0 \
                                else "&(cmd[%d] == '%s')" % (idx, cp)
                        idx += 1
                    py_code_nested_if += ":\n"
                    py_code_func_map += ")\n%sreturn\n" % (intend * 3)
                    py_code_export_one = py_code_nested_if + py_code_import_func + py_code_func_map
                    final_py += py_code_export_one
        save_text(os.path.join(self.pwd, "cmd_core", "cmd_parser.py"), final_py)
        print("Found %d commands" % cnt)

    def find_all_deps(self):
        self.search_down_sub_path(self.pwd)
        for f in self.file_to_check:
            self.find_dep_in_py_file(f)
            self.find_apt_dep_in_py_file(f)
        print(self.generate_apt_cmd())
        print(self.generate_pip_cmd())
        # print("-i https://pypi.tuna.tsinghua.edu.cn/simple")

    def find_dep_in_py_file(self, path):
        content = load_text(path)
        content = [x.strip() for x in content]
        for l in content:
            try:
                res = re.search(r"DEPENDENCY\(([-a-zA-Z0-9 ]+)\)", l).group(1).lstrip().rstrip().split(" ")
                for r in res:
                    if r not in self.dep_list:
                        self.dep_list.append(r)
            except AttributeError:
                continue

    def find_apt_dep_in_py_file(self, path):
        content = load_text(path)
        content = [x.strip() for x in content]
        for l in content:
            try:
                res_apt = re.search(r"DEP_APT\(([-a-zA-Z0-9 ]+)\)", l).group(1).lstrip().rstrip().split(" ")
                for r in res_apt:
                    if r not in self.dep_list:
                        self.apt_dep_list.append(r)
            except AttributeError:
                continue

    def find_todo_in_py_file(self, path):
        content = load_text(path)
        content = [x.strip() for x in content]
        for l in content:
            try:
                # noinspection RegExpRedundantEscape
                res = re.search(r"#[ \t]*[tT][oO][dD][oO][:,.a-zA-Z0-9_\(\) ]*", l).group(0)
                if res not in self.todo_list:
                    self.todo_list.append(res + "\t\t\t(%s)" % path)
            except AttributeError:
                continue

    def find_all_todos(self):
        self.search_down_sub_path(self.pwd)
        for f in self.file_to_check:
            self.find_todo_in_py_file(f)
        print("######## %d TODOs remaining ########" % len(self.todo_list))
        for i in self.todo_list:
            print(i)

    def find_not_windows_guaranteed(self):
        self.search_down_sub_path(self.pwd)
        for path in self.file_to_check:
            with open(path, encoding='utf-8') as f:
                content = f.readlines()
            content = [x.strip() for x in content]
            found = False
            for l in content:
                if re.search(r"# WINDOWS_GUARANTEED", l) is not None:
                    found = True
                    break
            if not found:
                print(path)

    def generate_pip_cmd(self):
        res = ''
        if "tushare" in self.dep_list:  # CAUTION: tushare has bad dependency which should be installed at last
            self.dep_list.remove("tushare")
            res += "sudo -H pip3 install " + " ".join(self.dep_list) + "\n"
            res += "sudo -H pip3 install tushare"

        else:
            res += "sudo -H pip3 install " + " ".join(self.dep_list)
        return res

    def generate_apt_cmd(self):
        return "sudo apt-get install -y " + " ".join(self.apt_dep_list)


if __name__ == '__main__':

    a = OverviewHdl()
    if '-d' in sys.argv:
        a.find_all_deps()
    elif '-t' in sys.argv:
        a.find_all_todos()
    elif '-w' in sys.argv:
        a.find_not_windows_guaranteed()
    elif '-c' in sys.argv:
        a.build_cmd_cache()
    else:
        print(" -d for find all dependencies.\n"
              " -t for find all TODOs.\n"
              " -w to see which part cannot run under windows.\n"
              " -c update available command cache.")
