# -*- coding: utf-8 -*-
import os
import re
import sys


# IMPORTANT: overview.py provides vital information and do initializations for the whole project.
#           this file SHOULD NOT import any other third party modules as well as classes or functions elsewhere
#           within this project to make sure all functions implemented here can be run on any fresh python3 environments
#           with minimal or no other third party packages currently installed.

# Current Implemented Functions:

#   find all dependencies
#       The whole project may depend tons of third-party packages, which we can install from apt-get or pip install,
#       however managing them would be a nightmare as project modules increasing. This function can help solving this
#       problem and generating proper install commands for all dependencies by searching comment marco:
#            # DEPENDENCY( pip-packages )
#            # DEP_APT( apt-packages )
#       through all files. So by putting such marco anywhere in the .py file within this project, dependency can be found
#       and handled properly.

#   find all TODOs:
#       print all TODOs of the whole project. Since I never add meaningful git comments this is the only effective way
#       for me to track project status.

#   find which part cannot run under windows:
#       If a .py file can run under windows, I add # WINDOWS_GUARANTEED comment marco to it. This function basically find
#       all .py files without such comment.

#   update available command cache
#       This function generates all contents of ./ctrl_executor/cmd_parser.py by scanning all .py files for function export
#       comment marco like:
#           # CMDEXPORT ( exported_cmd_alias {cmd_param1} {cmd_param2} ) python_function_name_to_export
#       Then you can use any exported alias in your .ctrl batch file.


def load_text(path):
    """
    naive text file loader

    Caution: other text hdl were implemented elsewhere in this project.
    However overview.py is designed as independent with all other modules, so we implement it here again.

    :param path: input text file path, string
    :return: a list of string, each string represents a line from text file

    """
    if not os.path.exists(path):
        print("TextLoader", "[ ERROR ] file not exist %s" % path)
        return None
    with open(path, encoding='utf8') as f:
        raw_text = f.readlines()
    return raw_text


def save_text(path, content):
    """
    Naive wrapper to save str content to text file.

    Caution: other text hdl were implemented elsewhere in this project.
    However overview.py is designed as independent with all other modules, so we implement it here again.

    :param path: output text file path, string
    :param content: your string to save, string
    """
    with open(path, "w", encoding='utf8') as f:
        f.write(content)


class OverviewHdl:
    """
    Start point after fresh clone on a fresh environment. Totally independent from other 3rd-party packages as well as
    classes and functions elsewhere within this project.
    """

    def __init__(self):
        self.pwd = os.getcwd()
        self.dep_list = []
        self.apt_dep_list = []
        self.file_to_check = []
        self.todo_list = []

    def search_down_sub_path(self, root):
        """
        Search code directory recursively, fill in file_to_check list with paths of .py files
        :param root: start root node of your directory tree, string
        """
        files = os.listdir(root)
        for f in files:
            if os.path.isdir(os.path.join(root, f)):
                self.search_down_sub_path(os.path.join(root, f))
            elif len(f.split(".")) == 2:
                if (f.split(".")[1] == "py") & (f.split(".")[0] != "overview"):
                    self.file_to_check.append(os.path.join(root, f))

    def _from_where(self, path):
        """
        helper function for build_cmd_cache, should not be used elsewhere.
        converting a path string "/dir/module.py" to "dir.module" which then be used to construct import command like
        "from dir.module import sth"
        :param path: path of .py file, string
        :return: path.py_file, string
        """
        tmp = re.sub(self.pwd, '', path).lstrip("/").split(".")[0]
        return re.sub("/", ".", tmp)

    def build_cmd_cache(self):
        """
        generate all python code of ./ctrl_executor/cmd_parser.py, should run after fresh clone or new functions were exported
        to the control framework.
        """
        print("Updating command cache")
        final_py = \
            "# -*- coding: utf-8 -*-\n# This file is automatic generated by overview.py\n\n\ndef exec_ctrl_cmd(model_name, cmd):\n"
        intend = "    "
        self.search_down_sub_path(self.pwd)
        cnt = 0
        for path in self.file_to_check:
            lines = load_text(path)
            for line in lines:
                if re.search(r"#[ \t]*CMDEXPORT[ \t]*\([ \t]*[a-zA-Z0-9_ {}\[\]:]+[ \t]*\)[ \t]*[a-zA-Z0-9_]+", line):
                    # this line contains a cmd export
                    res = re.search(
                        r"#[ \t]*CMDEXPORT[ \t]*\([ \t]*([a-zA-Z0-9_ {}\[\]:]+)[ \t]*\)[ \t]*([a-zA-Z0-9_]+)", line)
                    print(line.rstrip())
                    cnt += 1
                    exported = res.group(1).strip()
                    map_to_func = res.group(2)
                    cmd_and_params = exported.split(" ")
                    cmd_min_length = len(cmd_and_params)
                    for cp in cmd_and_params:
                        if re.search(r"{{[a-zA-Z0-9_:\[\]]*}}", cp):
                            cmd_min_length -= 1
                    py_code_nested_if = ''
                    py_code_func_map = '%s%s(' % (intend * 3, map_to_func)
                    py_code_import_func = '%sfrom %s import %s\n' % (intend * 3, self._from_where(path), map_to_func)
                    idx = 0
                    py_code_nested_if += "%sif len(cmd) >= %d:\n" % (intend, cmd_min_length) if ":" in line \
                        else "%sif len(cmd) == %d:\n" % (intend, cmd_min_length)
                    for cp in cmd_and_params:
                        if re.search(r"{{[a-zA-Z0-9_:\[\]]*}}", cp):
                            # special param, should keep what it is
                            py_code_func_map += cp.strip("{").strip("}")
                            py_code_func_map += ", " if cp != cmd_and_params[-1] else ""
                        elif re.search(r"{[a-zA-Z0-9_:\[\]]*}", cp):
                            # cp is a param
                            py_code_func_map += "cmd[%d]" % idx if ':' not in cp else "' '.join(cmd[%d:])" % idx
                            py_code_func_map += ", " if cp != cmd_and_params[-1] else ""
                            idx += 1
                        else:
                            # cp is a cmd
                            py_code_nested_if += "%sif (cmd[%d] == '%s') " % (intend * 2, idx, cp) if idx == 0 \
                                else "&(cmd[%d] == '%s')" % (idx, cp)
                            idx += 1
                    py_code_nested_if += ":\n"
                    py_code_func_map += ")\n%sreturn\n" % (intend * 3)
                    py_code_export_one = py_code_nested_if + py_code_import_func + py_code_func_map
                    final_py += py_code_export_one
        save_text(os.path.join(self.pwd, "tools", "ctrl_executor", "cmd_parser.py"), final_py)
        print("Found %d commands" % cnt)

    def find_all_deps(self):
        """
        print commands to install both apt dependencies and pip dependencies.
        However apt dependencies can only be install manually on windows since there doesn't exist a useful
        package management software for open-source software.
        """
        self.search_down_sub_path(self.pwd)
        for f in self.file_to_check:
            self.find_dep_in_py_file(f)
            self.find_apt_dep_in_py_file(f)
        print(self.generate_apt_cmd())
        print(self.generate_pip_cmd())
        # print("-i https://pypi.tuna.tsinghua.edu.cn/simple")

    def find_dep_in_py_file(self, path):
        """
        helper function for find_all_deps, should not be called elsewhere.
        :param path: .py path to search pip dependency comment marco.
        """
        content = load_text(path)
        content = [x.strip() for x in content]
        for l in content:
            try:
                res = re.search(r"DEPENDENCY\(([-a-zA-Z0-9 ]+)\)", l).group(1).lstrip().rstrip().split(" ")
                for r in res:
                    if r not in self.dep_list:
                        self.dep_list.append(r)
            except AttributeError:
                continue

    def find_apt_dep_in_py_file(self, path):
        """
        helper function for find_all_deps, should not be called elsewhere.
        :param path: .py path to search apt dependency comment marco.
        """
        content = load_text(path)
        content = [x.strip() for x in content]
        for l in content:
            try:
                res_apt = re.search(r"DEP_APT\(([-a-zA-Z0-9 ]+)\)", l).group(1).lstrip().rstrip().split(" ")
                for r in res_apt:
                    if r not in self.dep_list:
                        self.apt_dep_list.append(r)
            except AttributeError:
                continue

    def generate_pip_cmd(self):
        """
        helper function for find_all_deps, should not be called elsewhere.
        :return: install command string
        """
        res = ''
        if "tushare" in self.dep_list:  # CAUTION: tushare has bad dependency which should be installed at last
            self.dep_list.remove("tushare")
            res += "sudo -H pip3 install " + " ".join(self.dep_list) + "\n"
            res += "sudo -H pip3 install tushare"

        else:
            res += "sudo -H pip3 install " + " ".join(self.dep_list)
        return res

    def generate_apt_cmd(self):
        """
        helper function for find_all_deps, should not be called elsewhere.
        :return: install command string
        """
        return "sudo apt-get install -y " + " ".join(self.apt_dep_list)

    def find_todo_in_py_file(self, path):
        """
        helper function for find_all_todos, should not be called elsewhere.
        :param path:path of .py file to search
        """
        content = load_text(path)
        content = [x.strip() for x in content]
        for l in content:
            try:
                # noinspection RegExpRedundantEscape
                res = re.search(r"#[ \t]*[tT][oO][dD][oO][:,.a-zA-Z0-9_\(\) ]*", l).group(0)
                if res not in self.todo_list:
                    self.todo_list.append(res + "\t\t\t(%s)" % path)
            except AttributeError:
                continue

    def find_all_todos(self):
        """
        print TODOs in .py among whole project.
        """
        self.search_down_sub_path(self.pwd)
        for f in self.file_to_check:
            self.find_todo_in_py_file(f)
        print("######## %d TODOs remaining ########" % len(self.todo_list))
        for i in self.todo_list:
            print(i)

    def find_not_windows_guaranteed(self):
        """
        print .py files need to be tested under windows.
        """
        self.search_down_sub_path(self.pwd)
        for path in self.file_to_check:
            with open(path, encoding='utf-8') as f:
                content = f.readlines()
            content = [x.strip() for x in content]
            found = False
            for l in content:
                if re.search(r"# WINDOWS_GUARANTEED", l) is not None:
                    found = True
                    break
            if not found:
                print(path)


if __name__ == '__main__':

    a = OverviewHdl()
    if '-d' in sys.argv:
        a.find_all_deps()
    elif '-t' in sys.argv:
        a.find_all_todos()
    elif '-w' in sys.argv:
        a.find_not_windows_guaranteed()
    elif '-c' in sys.argv:
        a.build_cmd_cache()
    else:
        print(" -d for find all dependencies.\n"
              " -t for find all TODOs.\n"
              " -w to see which part cannot run under windows.\n"
              " -c update available command cache.")
